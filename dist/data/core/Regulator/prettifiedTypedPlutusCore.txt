(program 1.0.0 ((\fix1 -> (\Tuple2 -> (\Nil -> \Cons -> (\True -> \False -> (\goInner -> (\goOuter -> (\Unit -> (\ScriptCredential -> (\Just -> \Nothing -> (\Address -> (\unitval -> (\fail -> (\getPaymentPKH -> (\equalsByteString -> (\fEqAddress_c -> (\reconstructCaseError -> (\fUnsafeFromDataBool_cunsafeFromBuiltinData -> (\fUnsafeFromDataExtended_cunsafeFromBuiltinData -> (\fUnsafeFromDataCredential_cunsafeFromBuiltinData -> (\fUnsafeFromDataStakingCredential_cunsafeFromBuiltinData -> (\fUnsafeFromDataDCert_cunsafeFromBuiltinData -> (\fUnsafeFromDataTxId_cunsafeFromBuiltinData -> (\fUnsafeFromDataTxOutRef_cunsafeFromBuiltinData -> (\fUnsafeFromDataScriptContext_cunsafeFromBuiltinData -> (\fUnsafeFromDataMaybe_cunsafeFromBuiltinData -> (\fUnsafeFromDataAddress_cunsafeFromBuiltinData -> (\fUnsafeFromDataMap_cunsafeFromBuiltinData -> (\fUnsafeFromDataValue -> (\fUnsafeFromDataTxOut_cunsafeFromBuiltinData -> (\fUnsafeFromDataScriptContext_cunsafeFromBuiltinData -> (\fUnsafeFromDataNil_cunsafeFromBuiltinData -> (\fUnsafeFromDataScriptContext_cunsafeFromBuiltinData -> (\foldr -> (\ownCurrencySymbol -> (\CConsMonoid -> (\fFoldableNil_cfoldMap -> (\txSignedBy -> \ds -> \rawRedeemer -> (\tup -> (\index -> (\redeemer -> \rawCTX -> (\ds -> (\ctxTxInfo -> (\ctx -> force ds (\ds -> (\isDistroSCPresent -> (\txOutToDistro -> \ds -> (\go -> \ds -> \ds -> \ds -> \ds -> (\fail -> (\j -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> force ds (\ds -> \ds -> (\fail -> (\j -> (\fail -> (\j -> force (force (force redeemer) (\default_arg0 -> delay (fail ())) (delay (force (force txOutToDistro) (\ds -> \ds -> \ds -> \ds -> force (force ds (delay (force ((\thunk -> error) ((\wild -> unitval) (force trace "No Inline Datum" Unit))) (\happyToken -> \ds -> \ds -> j happyToken ds ds))) (\ds -> (\tup -> (\t -> (\t -> delay (force (force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> delay (\case_DistroDatum -> case_DistroDatum arg_0 arg_1 arg_2)) ((\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> force (force Tuple2) (unBData (force headList (force t))) (unBData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force t))) ((\d -> (\tup -> (\t -> (\t -> (\t -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> \arg_3 -> \arg_4 -> delay (\case_PhaseOneInfo -> case_PhaseOneInfo arg_0 arg_1 arg_2 arg_3 arg_4)) (unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force t))) (unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force t))) (unIData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force t))) ((\d -> (\tup -> (\t -> (\t -> (\t -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> \arg_3 -> \arg_4 -> delay (\case_PhaseTwoInfo -> case_PhaseTwoInfo arg_0 arg_1 arg_2 arg_3 arg_4)) (unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force t))) (unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force t))) (unIData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (\happyToken -> \ds -> \ds -> j happyToken ds ds))) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData ds))) (\default_arg0 -> delay (force ((\thunk -> error) ((\wild -> unitval) (force trace "No Inline Datum" Unit))) (\happyToken -> \ds -> \ds -> j happyToken ds ds))))))) (delay (fail ())) (\default_arg0 -> delay (fail ())))) (\happyToken -> \ds -> \ds -> force ds (\firstDevPhaseOneClaimAmount -> \firstDevDidPhaseOne -> \secondDevPhaseOneClaimAmount -> \secondDevDidPhaseOne -> \dateOfPhaseOne -> force ds (\firstDevPhaseTwoClaimAmount -> \firstDevDidPhaseTwo -> \secondDevPhaseTwoClaimAmount -> \secondDevDidPhaseTwo -> \dateOfPhaseTwo -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> force (force ds) (\ctx -> \txInfoInputs -> \txInfoReferenceInputs -> \txInfoOutputs -> \txInfoFee -> \txInfoMint -> \txInfoDCert -> \txInfoWdrl -> \txInfoValidRange -> \txInfoSignatories -> \txInfoRedeemers -> \txInfoData -> \txInfoId -> force (force (goOuter (force Nil) txInfoMint) (delay (force j)) (\ds -> \ds -> delay (force ds (\cs -> \ds -> \amt -> force (force ds (delay (force (force (force ifThenElse (equalsByteString cs (ownCurrencySymbol (force ctx))) True False) (delay (force (force (force ifThenElse (equalsInteger amt 1) True False) (delay (force j)) (delay (force j))))) (delay (force j))))) (\ipv -> \ipv -> delay (force j))))))))) (delay (force (force (force trace "Only 1 Happy Token Must Be Minted" False) (delay (force j)) (delay (fail ())))))) (delay (force (force (force ifThenElse (equalsInteger (force (force txOutToDistro) (\ds -> \ds -> \ds -> \ds -> (\cur -> (\go -> go ds) ((\arg_0 -> arg_0) (force (force fix1) (\go -> \ds -> force ds 0 (\ds -> \xs -> force ds (\c -> \i -> force (force (force ifThenElse (equalsByteString c cur) True False) (delay (go i)) (delay (go xs))))))))) (ownCurrencySymbol (force ctx)))) 1) True False) (delay (force j)) (delay (force (force (force trace "Happy Token Must Be At Distro SC Output" False) (delay (force j)) (delay (fail ()))))))))) (delay (force (force ((\w -> force happyToken (\ww -> \ww -> force w (\ww -> \ww -> force (force (force ifThenElse (equalsByteString ww ww) True False) (delay (equalsByteString ww ww)) (delay False))))) (force (force Tuple2) (ownCurrencySymbol (force ctx)) ds)) (delay (force j)) (delay (force (force (force trace "Happy Token Info Mismatched" False) (delay (force j)) (delay (fail ()))))))))) (delay (force (force (force ifThenElse (equalsInteger ds firstDevPhaseOneClaimAmount) True False) (delay (force j)) (delay (force (force (force trace "firstDevPhaseOneClaimAmount Mismatched" False) (delay (force j)) (delay (fail ()))))))))) (delay (force (force ds (delay (force (force firstDevDidPhaseOne (delay (force j)) (delay (force j))))) (delay (force (force firstDevDidPhaseOne (delay (force j)) (delay (force j))))))))) (delay (force (force (force trace "firstDevDidPhaseOne Mismatched" False) (delay (force j)) (delay (fail ())))))) (delay (force (force (force ifThenElse (equalsInteger ds secondDevPhaseOneClaimAmount) True False) (delay (force j)) (delay (force (force (force trace "secondDevPhaseOneClaimAmount Mismatched" False) (delay (force j)) (delay (fail ()))))))))) (delay (force (force ds (delay (force (force secondDevDidPhaseOne (delay (force j)) (delay (force j))))) (delay (force (force secondDevDidPhaseOne (delay (force j)) (delay (force j))))))))) (delay (force (force (force trace "secondDevDidPhaseOne Mismatched" False) (delay (force j)) (delay (fail ())))))) (delay (force (force (force ifThenElse (equalsInteger ds dateOfPhaseOne) True False) (delay (force j)) (delay (force (force (force trace "dateOfPhaseOne Mismatched" False) (delay (force j)) (delay (fail ()))))))))) (delay (force (force (force ifThenElse (equalsInteger ds firstDevPhaseTwoClaimAmount) True False) (delay (force j)) (delay (force (force (force trace "firstDevPhaseTwoClaimAmount Mismatched" False) (delay (force j)) (delay (fail ()))))))))) (delay (force (force ds (delay (force (force firstDevDidPhaseTwo (delay (force j)) (delay (force j))))) (delay (force (force firstDevDidPhaseTwo (delay (force j)) (delay (force j))))))))) (delay (force (force (force trace "firstDevDidPhaseTwo Mismatched" False) (delay (force j)) (delay (fail ())))))) (delay (force (force (force ifThenElse (equalsInteger ds secondDevPhaseTwoClaimAmount) True False) (delay (force j)) (delay (force (force (force trace "secondDevPhaseTwoClaimAmount Mismatched" False) (delay (force j)) (delay (fail ()))))))))) (delay (force (force ds (delay (force (force secondDevDidPhaseTwo (delay (force j)) (delay (force j))))) (delay (force (force secondDevDidPhaseTwo (delay (force j)) (delay (force j))))))))) (delay (force (force (force trace "secondDevDidPhaseTwo Mismatched" False) (delay (force j)) (delay (fail ())))))) (delay (force (force (force ifThenElse (equalsInteger ds dateOfPhaseTwo) True False) (delay Unit) (delay (force (force (force trace "dateOfPhaseTwo Mismatched" False) (delay Unit) (delay (fail ())))))))))))) (\ds -> force (force (force redeemer) (\firstDevAddress -> (\j -> delay (force (force (txSignedBy (force ctxTxInfo) (getPaymentPKH ds)) (delay (force j)) (delay (force (force (force trace "First Developer Must Sign" False) (delay (force j)) (delay (fail ())))))))) (delay (force (force (fEqAddress_c ds firstDevAddress) (delay (force j)) (delay (force (force (force trace "First Developer Address Mismatch" False) (delay (force j)) (delay (fail ()))))))))) (delay (fail ())) (delay (fail ())) (\default_arg0 -> delay (fail ()))))) (delay (force (force (force isDistroSCPresent) (delay Unit) (delay (force (force (force trace "Distro Contract Must Be Present at Tx" False) (delay Unit) (delay (fail ()))))))))) (\ds -> force (force (force redeemer) (\default_arg0 -> delay (fail ())) (delay (fail ())) (delay (fail ())) (\secondDevAddress -> (\j -> delay (force (force (txSignedBy (force ctxTxInfo) (getPaymentPKH ds)) (delay (force j)) (delay (force (force (force trace "Second Developer Must Sign" False) (delay (force j)) (delay (fail ())))))))) (delay (force (force (fEqAddress_c ds secondDevAddress) (delay (force j)) (delay (force (force (force trace "Second Developer Address Mismatch" False) (delay (force j)) (delay (fail ()))))))))))))))) (delay (force (force (force isDistroSCPresent) (delay Unit) (delay (force (force (force trace "Distro Contract Must Be Present at Tx" False) (delay Unit) (delay (fail ()))))))))) (\ds -> force (force (force redeemer) (\default_arg0 -> delay error) (delay error) (delay (force (force (txSignedBy (force ctxTxInfo) ds) (delay Unit) (delay (force (force (force trace "Regulator Debugger Must Sign" False) (delay Unit) (delay error))))))) (\default_arg0 -> delay error)))) ((\arg_0 -> arg_0) (force (force fix1) (\go -> \ds -> force ds 0 (\ds -> \xs -> force ds (\c -> \i -> force (force (force ifThenElse (equalsByteString c ds) True False) (delay i) (delay (go xs))))))))) (delay (force (force ds) (\ctx -> \txInfoInputs -> \txInfoReferenceInputs -> \txInfoOutputs -> \txInfoFee -> \txInfoMint -> \txInfoDCert -> \txInfoWdrl -> \txInfoValidRange -> \txInfoSignatories -> \txInfoRedeemers -> \txInfoData -> \txInfoId -> force (force (force (force (foldr (delay (\x -> x)))) (\e -> \xs -> force e (\ds -> \ds -> \ds -> \ds -> force (force (fEqAddress_c ds (Address (ScriptCredential ds) (force Nothing))) (delay (force Cons e xs)) (delay xs)))) (force Nil) txInfoOutputs) (delay (fail ())) (\o -> \ds -> delay (force (force ds (delay o) (\ipv -> \ipv -> delay (fail ())))))))))) (delay (force (force ds) (\ctx -> \txInfoInputs -> \txInfoReferenceInputs -> \txInfoOutputs -> \txInfoFee -> \txInfoMint -> \txInfoDCert -> \txInfoWdrl -> \txInfoValidRange -> \txInfoSignatories -> \txInfoRedeemers -> \txInfoData -> \txInfoId -> force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) ((\v -> force CConsMonoid (\eta -> \eta -> force v (\v -> \v -> v) eta eta) (force v (\v -> \v -> v))) (delay (\case_CConsAdditiveMonoid -> case_CConsAdditiveMonoid (\l -> \r -> force (force l (delay True) (delay r))) False))) (\i -> force i (\ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> fEqAddress_c ds (Address (ScriptCredential ds) (force Nothing))))) txInfoInputs))))) (delay (force (force ds) (\ctx -> \txInfoInputs -> \txInfoReferenceInputs -> \txInfoOutputs -> \txInfoFee -> \txInfoMint -> \txInfoDCert -> \txInfoWdrl -> \txInfoValidRange -> \txInfoSignatories -> \txInfoRedeemers -> \txInfoData -> \txInfoId -> ctx)))) (delay (force (force ds) (\ctx -> \txInfoInputs -> \txInfoReferenceInputs -> \txInfoOutputs -> \txInfoFee -> \txInfoMint -> \txInfoDCert -> \txInfoWdrl -> \txInfoValidRange -> \txInfoSignatories -> \txInfoRedeemers -> \txInfoData -> \txInfoId -> force ctx (\ds -> \ds -> ds))))) (delay (force (fUnsafeFromDataScriptContext_cunsafeFromBuiltinData rawCTX) (\ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> (\arg_0 -> delay (\case_bad_name -> case_bad_name arg_0 ds ds ds ds ds ds ds ds ds ds ds ds)) (fUnsafeFromDataScriptContext_cunsafeFromBuiltinData rawCTX)))))) (delay (force ifThenElse (equalsInteger (force index) 4) (\ds -> delay (\case_FirstDeveloperAction -> \case_GenesisMint -> \case_RegulatorDebuggerAction -> \case_SecondDeveloperAction -> case_RegulatorDebuggerAction)) (\ds -> force ifThenElse (equalsInteger (force index) 3) (\ds -> (\arg_0 -> delay (\case_FirstDeveloperAction -> \case_GenesisMint -> \case_RegulatorDebuggerAction -> \case_SecondDeveloperAction -> case_SecondDeveloperAction arg_0)) (fUnsafeFromDataAddress_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 2) (\ds -> (\arg_0 -> delay (\case_FirstDeveloperAction -> \case_GenesisMint -> \case_RegulatorDebuggerAction -> \case_SecondDeveloperAction -> case_FirstDeveloperAction arg_0)) (fUnsafeFromDataAddress_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 1) (\ds -> delay (\case_FirstDeveloperAction -> \case_GenesisMint -> \case_RegulatorDebuggerAction -> \case_SecondDeveloperAction -> case_GenesisMint)) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) unitval) unitval))) (delay (force (force fstPair) (force tup)))) (delay (unConstrData rawRedeemer))) (\ds -> \k -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> force (force (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force CConsMonoid (\ds -> \b -> force (force ds (\ipv -> delay ds) (delay b))) (force Nothing)) (\x -> force (force (force ifThenElse (equalsByteString k x) True False) (delay (force Just x)) (delay (force Nothing)))) ds) (\ds -> delay True) (delay False))))) ((\arg_0 -> arg_0) (force (force fix1) (\fFoldableNil_cfoldMap -> \arg -> delay (delay (\dMonoid -> \ds -> \ds -> force (force ds (delay (force dMonoid (\v -> \v -> v))) (\x -> \xs -> delay (force dMonoid (\v -> \v -> v) (ds x) (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) dMonoid ds xs)))))))))) (delay (\arg_0 -> \arg_1 -> delay (\case_CConsMonoid -> case_CConsMonoid arg_0 arg_1)))) (\ds -> force ds (\ds -> \ds -> force ds (\default_arg0 -> (\thunk -> error) ((\wild -> unitval) (force trace "Lh" Unit))) (\cs -> cs) (\default_arg0 -> (\thunk -> error) ((\wild -> unitval) (force trace "Lh" Unit))) (\default_arg0 -> (\thunk -> error) ((\wild -> unitval) (force trace "Lh" Unit)))))) ((\arg_0 -> arg_0) (force (force fix1) (\foldr -> \arg -> delay (delay (\f -> \acc -> \l -> force (force l (delay acc) (\x -> \xs -> delay (f x (force (force (foldr (delay (\x -> x)))) f acc xs)))))))))) (\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_ScriptContext -> case_ScriptContext arg_0 arg_1)) ((\d -> (\tup -> (\t -> (\t -> (\t -> (\t -> (\t -> (\t -> (\t -> (\t -> (\t -> (\t -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> \arg_3 -> \arg_4 -> \arg_5 -> \arg_6 -> \arg_7 -> \arg_8 -> \arg_9 -> \arg_10 -> \arg_11 -> delay (\case_TxInfo -> case_TxInfo arg_0 arg_1 arg_2 arg_3 arg_4 arg_5 arg_6 arg_7 arg_8 arg_9 arg_10 arg_11)) (force fUnsafeFromDataNil_cunsafeFromBuiltinData fUnsafeFromDataScriptContext_cunsafeFromBuiltinData (force headList (force t))) (force fUnsafeFromDataNil_cunsafeFromBuiltinData fUnsafeFromDataScriptContext_cunsafeFromBuiltinData (force headList (force t))) (force fUnsafeFromDataNil_cunsafeFromBuiltinData fUnsafeFromDataTxOut_cunsafeFromBuiltinData (force headList (force t))) (force (force fUnsafeFromDataMap_cunsafeFromBuiltinData) unBData (force fUnsafeFromDataValue) (force headList (force t))) (force (force fUnsafeFromDataMap_cunsafeFromBuiltinData) unBData (force fUnsafeFromDataValue) (force headList (force t))) (force fUnsafeFromDataNil_cunsafeFromBuiltinData fUnsafeFromDataDCert_cunsafeFromBuiltinData (force headList (force t))) (force (force fUnsafeFromDataMap_cunsafeFromBuiltinData) fUnsafeFromDataStakingCredential_cunsafeFromBuiltinData unIData (force headList (force t))) ((\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_Interval -> case_Interval arg_0 arg_1)) ((\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_LowerBound -> case_LowerBound arg_0 arg_1)) (force fUnsafeFromDataExtended_cunsafeFromBuiltinData unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force t))) ((\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_UpperBound -> case_UpperBound arg_0 arg_1)) (force fUnsafeFromDataExtended_cunsafeFromBuiltinData unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force t))) (force fUnsafeFromDataNil_cunsafeFromBuiltinData unBData (force headList (force t))) (force (force fUnsafeFromDataMap_cunsafeFromBuiltinData) fUnsafeFromDataScriptContext_cunsafeFromBuiltinData (\d -> d) (force headList (force t))) (force (force fUnsafeFromDataMap_cunsafeFromBuiltinData) unBData (\d -> d) (force headList (force t))) (fUnsafeFromDataTxId_cunsafeFromBuiltinData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force t))) (fUnsafeFromDataScriptContext_cunsafeFromBuiltinData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d)))) (delay (\dUnsafeFromData -> (\go -> \d -> go (unListData d)) ((\arg_0 -> arg_0) (force (force fix1) (\go -> \l -> force (force chooseList) l (\ds -> force Nil) (\ds -> force Cons (dUnsafeFromData (force headList l)) (go (force tailList l))) Unit)))))) (\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_TxInInfo -> case_TxInInfo arg_0 arg_1)) (fUnsafeFromDataTxOutRef_cunsafeFromBuiltinData (force headList (force t))) (fUnsafeFromDataTxOut_cunsafeFromBuiltinData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d)))) (\d -> (\tup -> (\t -> (\t -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> \arg_3 -> delay (\case_TxOut -> case_TxOut arg_0 arg_1 arg_2 arg_3)) (fUnsafeFromDataAddress_cunsafeFromBuiltinData (force headList (force t))) (force (force fUnsafeFromDataMap_cunsafeFromBuiltinData) unBData (force fUnsafeFromDataValue) (force headList (force t))) ((\d -> (\tup -> (\index -> force ifThenElse (equalsInteger (force index) 2) (\ds -> (\arg_0 -> delay (\case_NoOutputDatum -> \case_OutputDatum -> \case_OutputDatumHash -> case_OutputDatum arg_0)) (force headList (force (force sndPair) (force tup)))) (\ds -> force ifThenElse (equalsInteger (force index) 1) (\ds -> (\arg_0 -> delay (\case_NoOutputDatum -> \case_OutputDatum -> \case_OutputDatumHash -> case_OutputDatumHash arg_0)) (unBData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> delay (\case_NoOutputDatum -> \case_OutputDatum -> \case_OutputDatumHash -> case_NoOutputDatum)) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (unConstrData d))) (force headList (force t))) (force fUnsafeFromDataMaybe_cunsafeFromBuiltinData unBData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d)))) (delay (force (force fUnsafeFromDataMap_cunsafeFromBuiltinData) unBData unIData))) (delay (delay (\dUnsafeFromData -> \dUnsafeFromData -> (\go -> \d -> go (unMapData d)) ((\arg_0 -> arg_0) (force (force fix1) (\go -> \l -> (\tup -> force (force chooseList) l (\ds -> force Nil) (\ds -> force Cons (force (force Tuple2) (dUnsafeFromData (force (force fstPair) (force tup))) (dUnsafeFromData (force (force sndPair) (force tup)))) (go (force tailList l))) Unit) (delay (force headList l))))))))) (\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> Address (fUnsafeFromDataCredential_cunsafeFromBuiltinData (force headList (force t))) (force fUnsafeFromDataMaybe_cunsafeFromBuiltinData fUnsafeFromDataStakingCredential_cunsafeFromBuiltinData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d)))) (delay (\dUnsafeFromData -> \d -> (\tup -> (\index -> force ifThenElse (equalsInteger (force index) 0) (\ds -> force Just (dUnsafeFromData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 1) (\ds -> force Nothing) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (unConstrData d))))) (\d -> (\tup -> (\index -> force ifThenElse (equalsInteger (force index) 3) (\ds -> (\arg_0 -> delay (\case_Certifying -> \case_Minting -> \case_Rewarding -> \case_Spending -> case_Certifying arg_0)) (fUnsafeFromDataDCert_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 2) (\ds -> (\arg_0 -> delay (\case_Certifying -> \case_Minting -> \case_Rewarding -> \case_Spending -> case_Rewarding arg_0)) (fUnsafeFromDataStakingCredential_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 1) (\ds -> (\arg_0 -> delay (\case_Certifying -> \case_Minting -> \case_Rewarding -> \case_Spending -> case_Spending arg_0)) (fUnsafeFromDataTxOutRef_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> (\arg_0 -> delay (\case_Certifying -> \case_Minting -> \case_Rewarding -> \case_Spending -> case_Minting arg_0)) (unBData (force headList (force (force sndPair) (force tup))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (unConstrData d)))) (\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_TxOutRef -> case_TxOutRef arg_0 arg_1)) (fUnsafeFromDataTxId_cunsafeFromBuiltinData (force headList (force t))) (unIData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d)))) (\d -> (\tup -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> unBData (force headList (force (force sndPair) (force tup)))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (unConstrData d)))) (\d -> (\tup -> (\t -> (\t -> (\t -> (\index -> force ifThenElse (equalsInteger (force index) 6) (\ds -> delay (\case_DCertDelegDeRegKey -> \case_DCertDelegDelegate -> \case_DCertDelegRegKey -> \case_DCertGenesis -> \case_DCertMir -> \case_DCertPoolRegister -> \case_DCertPoolRetire -> case_DCertMir)) (\ds -> force ifThenElse (equalsInteger (force index) 5) (\ds -> delay (\case_DCertDelegDeRegKey -> \case_DCertDelegDelegate -> \case_DCertDelegRegKey -> \case_DCertGenesis -> \case_DCertMir -> \case_DCertPoolRegister -> \case_DCertPoolRetire -> case_DCertGenesis)) (\ds -> force ifThenElse (equalsInteger (force index) 4) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_DCertDelegDeRegKey -> \case_DCertDelegDelegate -> \case_DCertDelegRegKey -> \case_DCertGenesis -> \case_DCertMir -> \case_DCertPoolRegister -> \case_DCertPoolRetire -> case_DCertPoolRetire arg_0 arg_1)) (unBData (force headList (force t))) (unIData (force headList (force tailList (force t))))) (\ds -> force ifThenElse (equalsInteger (force index) 3) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_DCertDelegDeRegKey -> \case_DCertDelegDelegate -> \case_DCertDelegRegKey -> \case_DCertGenesis -> \case_DCertMir -> \case_DCertPoolRegister -> \case_DCertPoolRetire -> case_DCertPoolRegister arg_0 arg_1)) (unBData (force headList (force t))) (unBData (force headList (force tailList (force t))))) (\ds -> force ifThenElse (equalsInteger (force index) 2) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_DCertDelegDeRegKey -> \case_DCertDelegDelegate -> \case_DCertDelegRegKey -> \case_DCertGenesis -> \case_DCertMir -> \case_DCertPoolRegister -> \case_DCertPoolRetire -> case_DCertDelegDelegate arg_0 arg_1)) (fUnsafeFromDataStakingCredential_cunsafeFromBuiltinData (force headList (force t))) (unBData (force headList (force tailList (force t))))) (\ds -> force ifThenElse (equalsInteger (force index) 1) (\ds -> (\arg_0 -> delay (\case_DCertDelegDeRegKey -> \case_DCertDelegDelegate -> \case_DCertDelegRegKey -> \case_DCertGenesis -> \case_DCertMir -> \case_DCertPoolRegister -> \case_DCertPoolRetire -> case_DCertDelegDeRegKey arg_0)) (fUnsafeFromDataStakingCredential_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> (\arg_0 -> delay (\case_DCertDelegDeRegKey -> \case_DCertDelegDelegate -> \case_DCertDelegRegKey -> \case_DCertGenesis -> \case_DCertMir -> \case_DCertPoolRegister -> \case_DCertPoolRetire -> case_DCertDelegRegKey arg_0)) (fUnsafeFromDataStakingCredential_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) unitval) unitval) unitval) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (force (force sndPair) (force tup)))) (delay (force (force sndPair) (force tup)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d)))) (\d -> (\tup -> (\t -> (\t -> (\index -> force ifThenElse (equalsInteger (force index) 1) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> delay (\case_StakingHash -> \case_StakingPtr -> case_StakingPtr arg_0 arg_1 arg_2)) (unIData (force headList (force t))) (unIData (force headList (force t))) (unIData (force headList (force tailList (force t))))) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> (\arg_0 -> delay (\case_StakingHash -> \case_StakingPtr -> case_StakingHash arg_0)) (fUnsafeFromDataCredential_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d)))) (\d -> (\tup -> (\index -> force ifThenElse (equalsInteger (force index) 1) (\ds -> ScriptCredential (unBData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> (\arg_0 -> delay (\case_PubKeyCredential -> \case_ScriptCredential -> case_PubKeyCredential arg_0)) (unBData (force headList (force (force sndPair) (force tup))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (unConstrData d)))) (delay (\dUnsafeFromData -> \d -> (\tup -> (\index -> force ifThenElse (equalsInteger (force index) 2) (\ds -> delay (\case_Finite -> \case_NegInf -> \case_PosInf -> case_PosInf)) (\ds -> force ifThenElse (equalsInteger (force index) 1) (\ds -> (\arg_0 -> delay (\case_Finite -> \case_NegInf -> \case_PosInf -> case_Finite arg_0)) (dUnsafeFromData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> delay (\case_Finite -> \case_NegInf -> \case_PosInf -> case_NegInf)) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (unConstrData d))))) (\d -> (\index -> force ifThenElse (equalsInteger (force index) 1) (\ds -> True) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> False) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) (delay (force (force fstPair) (unConstrData d))))) "PT1") (\w -> \w -> force w (\ww -> \ww -> force w (\ww -> \ww -> (\j -> force ww (\l -> force ww (\r -> force (force (force ifThenElse (equalsByteString l r) True False) (delay (force j)) (delay False))) (\ipv -> False)) (\a -> force ww (\ipv -> False) (\a -> force (force (force ifThenElse (equalsByteString a a) True False) (delay (force j)) (delay False))))) (delay (force (force ww (\a -> delay (force (force ww (\a -> delay (force a (\l -> force a (\r -> force l (\l -> force r (\r -> equalsByteString l r) (\ipv -> False)) (\a -> force r (\ipv -> False) (\a -> equalsByteString a a))) (\ipv -> \ipv -> \ipv -> False)) (\a -> \b -> \c -> force a (\ipv -> False) (\a -> \b -> \c -> force (force (force ifThenElse (equalsInteger a a) True False) (delay (force (force (force ifThenElse (equalsInteger b b) True False) (delay (force ifThenElse (equalsInteger c c) True False)) (delay False)))) (delay False)))))) (delay False)))) (delay (force (force ww (\ipv -> delay False) (delay True))))))))))) (\x -> \y -> force ifThenElse (equalsByteString x y) True False)) (\address -> force address (\ds -> \ds -> force ds (\k -> k) (\ipv -> (\thunk -> error) ((\wild -> unitval) (force trace "No PubKeyHash" Unit)))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace "No TxOut To Distro SC" Unit)))) ()) (\arg_0 -> \arg_1 -> delay (\case_Address -> case_Address arg_0 arg_1))) (delay (\arg_0 -> delay (\case_Just -> \case_Nothing -> case_Just arg_0))) (delay (delay (\case_Just -> \case_Nothing -> case_Nothing)))) (\arg_0 -> delay (\case_PubKeyCredential -> \case_ScriptCredential -> case_ScriptCredential arg_0))) (delay (\case_Unit -> case_Unit))) ((\arg_0 -> arg_0) (force (force fix1) (\goOuter -> \acc -> \ds -> force (force ds (delay acc) (\ipv -> \ipv -> delay (force ipv (\cs -> \m -> goOuter (goInner cs acc m) ipv)))))))) ((\arg_0 -> arg_0) (force (force fix1) (\goInner -> \ds -> \acc -> \ds -> force (force ds (delay acc) (\ipv -> \ipv -> delay (force ipv (\tn -> \a -> force (force (force ifThenElse (equalsInteger a 0) True False) (delay (goInner ds acc ipv)) (delay (goInner ds (force Cons (delay (\case_Tuple3 -> case_Tuple3 ds tn a)) acc) ipv))))))))))) (delay (\case_True -> \case_False -> case_True)) (delay (\case_True -> \case_False -> case_False))) (delay (delay (\case_Nil -> \case_Cons -> case_Nil))) (delay (\arg_0 -> \arg_1 -> delay (\case_Nil -> \case_Cons -> case_Cons arg_0 arg_1)))) (delay (delay (\arg_0 -> \arg_1 -> delay (\case_Tuple2 -> case_Tuple2 arg_0 arg_1))))) (delay (delay (\f -> (\s -> s s) (\s -> \x -> f (s s) x)))) (force (delay (\GHC_Types_True -> \GHC_Types_False -> \match_GHC_Types_Bool -> force (delay (\Distro_DataTypes_PhaseOneInfo -> \match_Distro_DataTypes_PhaseOneInfo -> force (delay (\Distro_DataTypes_PhaseTwoInfo -> \match_Distro_DataTypes_PhaseTwoInfo -> force (delay (\GHC_Maybe_Just -> \GHC_Maybe_Nothing -> \match_GHC_Maybe_Maybe -> force (delay (\Plutus_V1_Ledger_Credential_PubKeyCredential -> \Plutus_V1_Ledger_Credential_ScriptCredential -> \match_Plutus_V1_Ledger_Credential_Credential -> force (delay (\Plutus_V1_Ledger_Credential_StakingHash -> \Plutus_V1_Ledger_Credential_StakingPtr -> \match_Plutus_V1_Ledger_Credential_StakingCredential -> force (delay (\Plutus_V1_Ledger_Address_Address -> \match_Plutus_V1_Ledger_Address_Address -> force (delay (\Regulator_DataTypes_DevTeamAddresses -> \match_Regulator_DataTypes_DevTeamAddresses -> force (delay (\Regulator_DataTypes_RegulatorParams -> \match_Regulator_DataTypes_RegulatorParams -> Regulator_DataTypes_RegulatorParams #90f9ff81867c70842c658036c45551c62be7cf1363c3e6fb14334c95 #48415050595f544f4b454e (Distro_DataTypes_PhaseOneInfo 10000 GHC_Types_False 20000 GHC_Types_False 1673444643000) (Distro_DataTypes_PhaseTwoInfo 90000 GHC_Types_False 180000 GHC_Types_False 1673445243000) (Regulator_DataTypes_DevTeamAddresses (Plutus_V1_Ledger_Address_Address (Plutus_V1_Ledger_Credential_PubKeyCredential #cbbfc3e193813ee338d40eb0f4f178d46245e0d87adc4e9e8e0be489) (force GHC_Maybe_Just (Plutus_V1_Ledger_Credential_StakingHash (Plutus_V1_Ledger_Credential_PubKeyCredential #6683a4a58711b3c82a4daea1b607b3642f00164f3f28d14edc0f5031)))) (Plutus_V1_Ledger_Address_Address (Plutus_V1_Ledger_Credential_PubKeyCredential #5e822f882ae15a6598f04fdeac0e85423793c7d65164e36f3edbc48e) (force GHC_Maybe_Just (Plutus_V1_Ledger_Credential_StakingHash (Plutus_V1_Ledger_Credential_PubKeyCredential #4eed7b2060846bbccb19b08caa58ced3ad4b005daca450b5c147f97d))))) #bdc24850053ddf1e0c53bf20a518dcc4dcc5200ac4adb0056a1ded5c)) (\arg_0 -> \arg_1 -> \arg_2 -> \arg_3 -> \arg_4 -> \arg_5 -> delay (\case_Regulator_DataTypes_RegulatorParams -> case_Regulator_DataTypes_RegulatorParams arg_0 arg_1 arg_2 arg_3 arg_4 arg_5)) (\x -> x))) (\arg_0 -> \arg_1 -> delay (\case_Regulator_DataTypes_DevTeamAddresses -> case_Regulator_DataTypes_DevTeamAddresses arg_0 arg_1)) (\x -> x))) (\arg_0 -> \arg_1 -> delay (\case_Plutus_V1_Ledger_Address_Address -> case_Plutus_V1_Ledger_Address_Address arg_0 arg_1)) (\x -> x))) (\arg_0 -> delay (\case_Plutus_V1_Ledger_Credential_StakingHash -> \case_Plutus_V1_Ledger_Credential_StakingPtr -> case_Plutus_V1_Ledger_Credential_StakingHash arg_0)) (\arg_0 -> \arg_1 -> \arg_2 -> delay (\case_Plutus_V1_Ledger_Credential_StakingHash -> \case_Plutus_V1_Ledger_Credential_StakingPtr -> case_Plutus_V1_Ledger_Credential_StakingPtr arg_0 arg_1 arg_2)) (\x -> x))) (\arg_0 -> delay (\case_Plutus_V1_Ledger_Credential_PubKeyCredential -> \case_Plutus_V1_Ledger_Credential_ScriptCredential -> case_Plutus_V1_Ledger_Credential_PubKeyCredential arg_0)) (\arg_0 -> delay (\case_Plutus_V1_Ledger_Credential_PubKeyCredential -> \case_Plutus_V1_Ledger_Credential_ScriptCredential -> case_Plutus_V1_Ledger_Credential_ScriptCredential arg_0)) (\x -> x))) (delay (\arg_0 -> delay (\case_GHC_Maybe_Just -> \case_GHC_Maybe_Nothing -> case_GHC_Maybe_Just arg_0))) (delay (delay (\case_GHC_Maybe_Just -> \case_GHC_Maybe_Nothing -> case_GHC_Maybe_Nothing))) (delay (\x -> x)))) (\arg_0 -> \arg_1 -> \arg_2 -> \arg_3 -> \arg_4 -> delay (\case_Distro_DataTypes_PhaseTwoInfo -> case_Distro_DataTypes_PhaseTwoInfo arg_0 arg_1 arg_2 arg_3 arg_4)) (\x -> x))) (\arg_0 -> \arg_1 -> \arg_2 -> \arg_3 -> \arg_4 -> delay (\case_Distro_DataTypes_PhaseOneInfo -> case_Distro_DataTypes_PhaseOneInfo arg_0 arg_1 arg_2 arg_3 arg_4)) (\x -> x))) (delay (\case_GHC_Types_True -> \case_GHC_Types_False -> case_GHC_Types_True)) (delay (\case_GHC_Types_True -> \case_GHC_Types_False -> case_GHC_Types_False)) (\x -> x))))