(program 1.0.0 ((\fix1 -> (\True -> \False -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\j -> (\Unit -> (\Just -> \Nothing -> (\Tuple2 -> (\Nil -> \Cons -> (\unitval -> (\fail -> (\getPaymentPKH -> (\equalsInteger -> (\isNumOfInputsHasDatum -> (\isNumOutputsHasDatum -> (\equalsByteString -> (\fEqAssetClass -> (\fEqPhaseTwoInfo_c -> (\EQ -> \GT -> \LT -> (\fOrdPOSIXTime -> (\reconstructCaseError -> (\fUnsafeFromDataBool_cunsafeFromBuiltinData -> (\fUnsafeFromDataDistroDatum_cunsafeFromBuiltinData -> (\fUnsafeFromDataCredential_cunsafeFromBuiltinData -> (\fUnsafeFromDataAddress_cunsafeFromBuiltinData -> (\valueOf -> (\assetClassValueOf -> (\CConsMonoid -> (\fMonoidProduct -> (\fMultiplicativeMonoidBool -> (\p1Monoid -> (\mempty -> (\fFoldableNil_cfoldMap -> (\fFunctorNil_cfmap -> (\That -> \This -> (\foldr -> (\union -> (\checkBinRel -> (\compare -> (\Finite -> \PosInf -> (\hull_ccompare -> (\UpperBound -> (\fOrdUpperBound0_c -> (\LowerBound -> (\Interval -> (\contains -> (\goInner -> (\goOuter -> (\flattenValue -> (\fMonoidFirst -> (\findOwnInput -> (\getContinuingOutputs -> (\length -> (\txSignedBy -> \ds -> \datum -> \redeemer -> \ctx -> (\singleScriptOutputUTxO -> (\singleScriptInputUTxO -> force ctx (\ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> (\getMintingRedeemer -> \ds -> \ds -> force (force redeemer (\mintingContractCS -> delay (force datum (\happyToken -> \ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> force (force (getMintingRedeemer mintingContractCS) (\firstDevAddress -> delay (force (force (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidProduct (force fMultiplicativeMonoidBool)) (\ds -> ds) (force Cons (force (force (force ifThenElse (equalsByteString (force happyToken (\cs -> \ds -> cs)) mintingContractCS) True False) (delay True) (delay (force trace "Wrong Minting Contract Currency Symbol/Policy ID" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (assetClassValueOf ds happyToken) -1) True False) (delay True) (delay (force trace "Wrong Amount Minted By First Developer" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force (force length) (fFoldableNil_cfoldMap (delay (\x -> x))) (flattenValue ds)) 1) True False) (delay True) (delay (force trace "Only 1 Token Burn/Mint Action Is Allowed" False)))) (force Cons (force (force (txSignedBy (force ctx (\ds -> \ds -> ds)) (getPaymentPKH firstDevAddress)) (delay True) (delay (force trace "First Developer Must Sign Tx" False)))) (force Cons (force (force ds (delay (force (force ds (delay (force (force ds (delay (force (force ds (delay True) (delay (force j))))) (delay (force j))))) (delay (force j))))) (delay (force j)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Output UTxO Has No Happy State Token" False)))) (force Cons (force (force (isNumOfInputsHasDatum ds 1) (delay (force (force (isNumOutputsHasDatum (getContinuingOutputs ctx) 0) (delay True) (delay (force j))))) (delay (force j)))) (force Nil))))))))) (delay True) (delay (force trace "[ERROR]: FIRST DEVELOPER BURN GENESIS TOKEN" False))))) (delay error) (delay error) (\secondDevAddress -> delay (force (force (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidProduct (force fMultiplicativeMonoidBool)) (\ds -> ds) (force Cons (force (force (force ifThenElse (equalsByteString (force happyToken (\cs -> \ds -> cs)) mintingContractCS) True False) (delay True) (delay (force trace "Wrong Minting Contract Currency Symbol/Policy ID" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (assetClassValueOf ds happyToken) -1) True False) (delay True) (delay (force trace "Wrong Amount Minted By Second Developer" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force (force length) (fFoldableNil_cfoldMap (delay (\x -> x))) (flattenValue ds)) 1) True False) (delay True) (delay (force trace "Only 1 Token Burn/Mint Action Is Allowed" False)))) (force Cons (force (force (txSignedBy (force ctx (\ds -> \ds -> ds)) (getPaymentPKH secondDevAddress)) (delay True) (delay (force trace "Second Developer Must Sign Tx" False)))) (force Cons (force (force ds (delay (force (force ds (delay (force (force ds (delay (force (force ds (delay True) (delay (force j))))) (delay (force j))))) (delay (force j))))) (delay (force j)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Output UTxO Has No Happy State Token" False)))) (force Cons (force (force (isNumOfInputsHasDatum ds 1) (delay (force (force (isNumOutputsHasDatum (getContinuingOutputs ctx) 0) (delay True) (delay (force j))))) (delay (force j)))) (force Nil))))))))) (delay True) (delay (force trace "[ERROR]: SECOND DEVELOPER BURN GENESIS TOKEN" False))))))))))) (delay (force (force (txSignedBy (force ctx (\ds -> \ds -> ds)) ds) (delay True) (delay (force trace "Distro Debugger Must Sign" False))))) (\mintingContractCS -> delay (force datum (\happyToken -> \ds -> \phaseTwoInfo -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> force (force ds (delay (force trace "The Output UTxO Does Not Have Inlineeee Datum" False)) (\ds -> delay (force (fUnsafeFromDataDistroDatum_cunsafeFromBuiltinData ds) (\happyToken -> \ds -> \phaseTwoInfo -> force ds (\firstDevPhaseOneClaimAmount -> \firstDevDidPhaseOne -> \secondDevPhaseOneClaimAmount -> \secondDevDidPhaseOne -> \dateOfPhaseOne -> force (force (getMintingRedeemer mintingContractCS) (\firstDevAddress -> delay (force (force (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidProduct (force fMultiplicativeMonoidBool)) (\ds -> ds) (force Cons (force (force (force ifThenElse (equalsByteString (force happyToken (\cs -> \ds -> cs)) mintingContractCS) True False) (delay True) (delay (force trace "Wrong Minting Contract Currency Symbol/Policy ID" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (assetClassValueOf ds happyToken) ds) True False) (delay True) (delay (force trace "Wrong Amount Minted By First Developer" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force (force length) (fFoldableNil_cfoldMap (delay (\x -> x))) (flattenValue ds)) 1) True False) (delay True) (delay (force trace "Only 1 Token Burn/Mint Action Is Allowed" False)))) (force Cons (force (force (txSignedBy (force ctx (\ds -> \ds -> ds)) (getPaymentPKH firstDevAddress)) (delay True) (delay (force trace "First Developer Must Sign Tx" False)))) (force Cons (force (force ds (delay (force trace "Phase One Tokens Were Minted By First Dev" False)) (delay True))) (force Cons (force (force (fEqAssetClass happyToken happyToken) (delay True) (delay (force trace "happyToken Mismatch" False)))) (force Cons (force (force (force ifThenElse (equalsInteger ds firstDevPhaseOneClaimAmount) True False) (delay True) (delay (force trace "firstDevPhaseOneClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force firstDevDidPhaseOne (delay (force j)) (delay True)))) (delay (force (force firstDevDidPhaseOne (delay True) (delay (force j))))))) (force Cons (force (force (force ifThenElse (equalsInteger ds secondDevPhaseOneClaimAmount) True False) (delay True) (delay (force trace "secondDevPhaseOneClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force secondDevDidPhaseOne (delay True) (delay (force j))))) (delay (force (force secondDevDidPhaseOne (delay (force j)) (delay True)))))) (force Cons (force (force (force ifThenElse (equalsInteger ds dateOfPhaseOne) True False) (delay True) (delay (force trace "dateOfPhaseOne Mismatched" False)))) (force Cons (force (force (fEqPhaseTwoInfo_c phaseTwoInfo phaseTwoInfo) (delay True) (delay (force trace "phaseTwoInfo Mismatched" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Output UTxO Has No Happy State Token" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptInputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Input UTxO Has No Happy State Token" False)))) (force Cons (force (force singleScriptInputUTxO) (\ds -> \ds -> \ds -> \ds -> force (force (checkBinRel equalsInteger ds (force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> ds))) (delay True) (delay (force trace "Script Input & Output Must Be Equal" False))))) (force Cons (force (force (isNumOfInputsHasDatum ds 1) (delay (force (force (isNumOutputsHasDatum (getContinuingOutputs ctx) 1) (delay True) (delay (force j))))) (delay (force j)))) (force Nil)))))))))))))))))) (delay True) (delay (force trace "[ERROR]: FIRST DEVELOPER CLAIMS AT PHASE ONE" False))))) (delay error) (delay error) (\secondDevAddress -> delay (force (force (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidProduct (force fMultiplicativeMonoidBool)) (\ds -> ds) (force Cons (force (force (force ifThenElse (equalsByteString (force happyToken (\cs -> \ds -> cs)) mintingContractCS) True False) (delay True) (delay (force trace "Wrong Minting Contract Currency Symbol/Policy ID" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (assetClassValueOf ds happyToken) ds) True False) (delay True) (delay (force trace "Wrong Amount Minted By Second Developer" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force (force length) (fFoldableNil_cfoldMap (delay (\x -> x))) (flattenValue ds)) 1) True False) (delay True) (delay (force trace "Only 1 Token Burn/Mint Action Is Allowed" False)))) (force Cons (force (force (txSignedBy (force ctx (\ds -> \ds -> ds)) (getPaymentPKH secondDevAddress)) (delay True) (delay (force trace "Second Developer Must Sign Tx" False)))) (force Cons (force (force (force contains (force fOrdPOSIXTime) (force Interval (force LowerBound (force Finite ds) True) (force UpperBound (force PosInf) True)) ds) (delay True) (delay (force trace "Phase One Date Has Not Been Reached" False)))) (force Cons (force (force ds (delay (force trace "Phase One Tokens Were Minted By Second Dev" False)) (delay True))) (force Cons (force (force (fEqAssetClass happyToken happyToken) (delay True) (delay (force trace "happyToken Mismatch" False)))) (force Cons (force (force (force ifThenElse (equalsInteger ds firstDevPhaseOneClaimAmount) True False) (delay True) (delay (force trace "firstDevPhaseOneClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force firstDevDidPhaseOne (delay True) (delay (force j))))) (delay (force (force firstDevDidPhaseOne (delay (force j)) (delay True)))))) (force Cons (force (force (force ifThenElse (equalsInteger ds secondDevPhaseOneClaimAmount) True False) (delay True) (delay (force trace "secondDevPhaseOneClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force secondDevDidPhaseOne (delay (force j)) (delay True)))) (delay (force (force secondDevDidPhaseOne (delay True) (delay (force j))))))) (force Cons (force (force (force ifThenElse (equalsInteger ds dateOfPhaseOne) True False) (delay True) (delay (force trace "dateOfPhaseOne Mismatched" False)))) (force Cons (force (force (fEqPhaseTwoInfo_c phaseTwoInfo phaseTwoInfo) (delay True) (delay (force trace "phaseTwoInfo Mismatched" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Output UTxO Has No Happy State Token" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptInputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Input UTxO Has No Happy State Token" False)))) (force Cons (force (force singleScriptInputUTxO) (\ds -> \ds -> \ds -> \ds -> force (force (checkBinRel equalsInteger ds (force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> ds))) (delay True) (delay (force trace "Script Input & Output Must Be Equal" False))))) (force Cons (force (force (isNumOfInputsHasDatum ds 1) (delay (force (force (isNumOutputsHasDatum (getContinuingOutputs ctx) 1) (delay True) (delay (force j))))) (delay (force j)))) (force Nil))))))))))))))))))) (delay True) (delay (force trace "[ERROR]: SECOND DEVELOPER CLAIMS AT PHASE ONE" False)))))))))) (\default_arg0 -> delay (force trace "The Output UTxO Does Not Have Inlineeee Datum" False)))))))) (\mintingContractCS -> delay (force datum (\happyToken -> \ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> force (force ds (delay (force trace "The Output UTxO Does Not Have Inline Datum" False)) (\ds -> delay (force (fUnsafeFromDataDistroDatum_cunsafeFromBuiltinData ds) (\happyToken -> \ds -> \ds -> force ds (\firstDevPhaseOneClaimAmount -> \firstDevDidPhaseOne -> \secondDevPhaseOneClaimAmount -> \secondDevDidPhaseOne -> \dateOfPhaseOne -> force ds (\firstDevPhaseTwoClaimAmount -> \firstDevDidPhaseTwo -> \secondDevPhaseTwoClaimAmount -> \secondDevDidPhaseTwo -> \dateOfPhaseTwo -> force (force (getMintingRedeemer mintingContractCS) (\firstDevAddress -> delay (force (force (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidProduct (force fMultiplicativeMonoidBool)) (\ds -> ds) (force Cons (force (force (force ifThenElse (equalsByteString (force happyToken (\cs -> \ds -> cs)) mintingContractCS) True False) (delay True) (delay (force trace "Wrong Minting Contract Currency Symbol/Policy ID" False)))) (force Cons (force (force ds (delay (force (force (force ifThenElse (equalsInteger (assetClassValueOf ds happyToken) ds) True False) (delay True) (delay (force j))))) (delay (force (force (force ifThenElse (equalsInteger (assetClassValueOf ds happyToken) (addInteger ds ds)) True False) (delay True) (delay (force j))))))) (force Cons (force (force (force ifThenElse (equalsInteger (force (force length) (fFoldableNil_cfoldMap (delay (\x -> x))) (flattenValue ds)) 1) True False) (delay True) (delay (force trace "Only 1 Token Burn/Mint Action Is Allowed" False)))) (force Cons (force (force (txSignedBy (force ctx (\ds -> \ds -> ds)) (getPaymentPKH firstDevAddress)) (delay True) (delay (force trace "First Developer Must Sign Tx" False)))) (force Cons (force (force (force contains (force fOrdPOSIXTime) (force Interval (force LowerBound (force Finite ds) True) (force UpperBound (force PosInf) True)) ds) (delay True) (delay (force trace "Phase Two Date Has Not Been Reached" False)))) (force Cons (force (force ds (delay (force trace "Phase Two Tokens Were Minted By First Dev" False)) (delay True))) (force Cons (force (force (fEqAssetClass happyToken happyToken) (delay True) (delay (force trace "happyToken Mismatch" False)))) (force Cons (force (force (force ifThenElse (equalsInteger ds firstDevPhaseOneClaimAmount) True False) (delay True) (delay (force trace "firstDevPhaseOneClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force firstDevDidPhaseOne (delay True) (delay (force j))))) (delay (force (force firstDevDidPhaseOne (delay True) (delay (force j))))))) (force Cons (force (force (force ifThenElse (equalsInteger ds secondDevPhaseOneClaimAmount) True False) (delay True) (delay (force trace "secondDevPhaseOneClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force secondDevDidPhaseOne (delay True) (delay (force j))))) (delay (force (force secondDevDidPhaseOne (delay (force j)) (delay True)))))) (force Cons (force (force (force ifThenElse (equalsInteger ds dateOfPhaseOne) True False) (delay True) (delay (force trace "dateOfPhaseOne Mismatched" False)))) (force Cons (force (force (force ifThenElse (equalsInteger ds firstDevPhaseTwoClaimAmount) True False) (delay True) (delay (force trace "firstDevPhaseTwoClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force firstDevDidPhaseTwo (delay (force j)) (delay True)))) (delay (force (force firstDevDidPhaseTwo (delay True) (delay (force j))))))) (force Cons (force (force (force ifThenElse (equalsInteger ds secondDevPhaseTwoClaimAmount) True False) (delay True) (delay (force trace "secondDevPhaseTwoClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force secondDevDidPhaseTwo (delay True) (delay (force j))))) (delay (force (force secondDevDidPhaseTwo (delay (force j)) (delay True)))))) (force Cons (force (force (force ifThenElse (equalsInteger ds dateOfPhaseTwo) True False) (delay True) (delay (force trace "dateOfPhaseTwo Mismatched" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Output UTxO Has No Happy State Token" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptInputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Input UTxO Has No Happy State Token" False)))) (force Cons (force (force singleScriptInputUTxO) (\ds -> \ds -> \ds -> \ds -> force (force (checkBinRel equalsInteger ds (force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> ds))) (delay True) (delay (force trace "Script Input & Output Must Be Equal" False))))) (force Cons (force (force (isNumOfInputsHasDatum ds 1) (delay (force (force (isNumOutputsHasDatum (getContinuingOutputs ctx) 1) (delay True) (delay (force j))))) (delay (force j)))) (force Nil))))))))))))))))))))))) (delay True) (delay (force trace "[ERROR]: FIRST DEVELOPER CLAIMS AT PHASE TWO" False))))) (delay error) (delay error) (\secondDevAddress -> delay (force (force (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidProduct (force fMultiplicativeMonoidBool)) (\ds -> ds) (force Cons (force (force (force ifThenElse (equalsByteString (force happyToken (\cs -> \ds -> cs)) mintingContractCS) True False) (delay True) (delay (force trace "Wrong Minting Contract Currency Symbol/Policy ID" False)))) (force Cons (force (force ds (delay (force (force (force ifThenElse (equalsInteger (assetClassValueOf ds happyToken) ds) True False) (delay True) (delay (force j))))) (delay (force (force (force ifThenElse (equalsInteger (assetClassValueOf ds happyToken) (addInteger ds ds)) True False) (delay True) (delay (force j))))))) (force Cons (force (force (force ifThenElse (equalsInteger (force (force length) (fFoldableNil_cfoldMap (delay (\x -> x))) (flattenValue ds)) 1) True False) (delay True) (delay (force trace "Only 1 Token Burn/Mint Action Is Allowed" False)))) (force Cons (force (force (txSignedBy (force ctx (\ds -> \ds -> ds)) (getPaymentPKH secondDevAddress)) (delay True) (delay (force trace "Second Developer Must Sign Tx" False)))) (force Cons (force (force (force contains (force fOrdPOSIXTime) (force Interval (force LowerBound (force Finite ds) True) (force UpperBound (force PosInf) True)) ds) (delay True) (delay (force trace "Phase Two Date Has Not Been Reached" False)))) (force Cons (force (force ds (delay (force trace "Phase Two Tokens Were Minted By Second Dev" False)) (delay True))) (force Cons (force (force (fEqAssetClass happyToken happyToken) (delay True) (delay (force trace "happyToken Mismatch" False)))) (force Cons (force (force (force ifThenElse (equalsInteger ds firstDevPhaseOneClaimAmount) True False) (delay True) (delay (force trace "firstDevPhaseOneClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force firstDevDidPhaseOne (delay True) (delay (force j))))) (delay (force (force firstDevDidPhaseOne (delay (force j)) (delay True)))))) (force Cons (force (force (force ifThenElse (equalsInteger ds secondDevPhaseOneClaimAmount) True False) (delay True) (delay (force trace "secondDevPhaseOneClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force secondDevDidPhaseOne (delay True) (delay (force j))))) (delay (force (force secondDevDidPhaseOne (delay True) (delay (force j))))))) (force Cons (force (force (force ifThenElse (equalsInteger ds dateOfPhaseOne) True False) (delay True) (delay (force trace "dateOfPhaseOne Mismatched" False)))) (force Cons (force (force (force ifThenElse (equalsInteger ds firstDevPhaseTwoClaimAmount) True False) (delay True) (delay (force trace "firstDevPhaseTwoClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force firstDevDidPhaseTwo (delay True) (delay (force j))))) (delay (force (force firstDevDidPhaseTwo (delay (force j)) (delay True)))))) (force Cons (force (force (force ifThenElse (equalsInteger ds secondDevPhaseTwoClaimAmount) True False) (delay True) (delay (force trace "secondDevPhaseTwoClaimAmount Mismatched" False)))) (force Cons (force (force ds (delay (force (force secondDevDidPhaseTwo (delay (force j)) (delay True)))) (delay (force (force secondDevDidPhaseTwo (delay True) (delay (force j))))))) (force Cons (force (force (force ifThenElse (equalsInteger ds dateOfPhaseTwo) True False) (delay True) (delay (force trace "dateOfPhaseTwo Mismatched" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Output UTxO Has No Happy State Token" False)))) (force Cons (force (force (force ifThenElse (equalsInteger (force happyToken (\c -> \t -> force (force singleScriptInputUTxO) (\ds -> \ds -> \ds -> \ds -> valueOf ds c t))) 1) True False) (delay True) (delay (force trace "SC Input UTxO Has No Happy State Token" False)))) (force Cons (force (force singleScriptInputUTxO) (\ds -> \ds -> \ds -> \ds -> force (force (checkBinRel equalsInteger ds (force (force singleScriptOutputUTxO) (\ds -> \ds -> \ds -> \ds -> ds))) (delay True) (delay (force trace "Script Input & Output Must Be Equal" False))))) (force Cons (force (force (isNumOfInputsHasDatum ds 1) (delay (force (force (isNumOutputsHasDatum (getContinuingOutputs ctx) 1) (delay True) (delay (force j))))) (delay (force j)))) (force Nil))))))))))))))))))))))) (delay True) (delay (force trace "[ERROR]: SECOND DEVELOPER CLAIMS AT PHASE TWO" False))))))))))) (\default_arg0 -> delay (force trace "The Output UTxO Does Not Have Inline Datum" False))))))))))) (\cs -> (\go -> go ds) ((\arg_0 -> arg_0) (force (force fix1) (\go -> \ds -> force (force ds (delay ((\thunk -> error) ((\wild -> unitval) (force trace "No Redeemer Found" Unit)))) (\ds -> \xs -> delay (force ds (\c -> \i -> (\tup -> (\index -> force c (\cert -> go xs) (\cs -> force (force (force ifThenElse (equalsByteString cs cs) True False) (delay (force ifThenElse (equalsInteger (force index) 4) (\ds -> delay (\case_FirstDeveloperAction -> \case_GenesisMint -> \case_RegulatorDebuggerAction -> \case_SecondDeveloperAction -> case_RegulatorDebuggerAction)) (\ds -> force ifThenElse (equalsInteger (force index) 3) (\ds -> (\arg_0 -> delay (\case_FirstDeveloperAction -> \case_GenesisMint -> \case_RegulatorDebuggerAction -> \case_SecondDeveloperAction -> case_SecondDeveloperAction arg_0)) (fUnsafeFromDataAddress_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 2) (\ds -> (\arg_0 -> delay (\case_FirstDeveloperAction -> \case_GenesisMint -> \case_RegulatorDebuggerAction -> \case_SecondDeveloperAction -> case_FirstDeveloperAction arg_0)) (fUnsafeFromDataAddress_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 1) (\ds -> delay (\case_FirstDeveloperAction -> \case_GenesisMint -> \case_RegulatorDebuggerAction -> \case_SecondDeveloperAction -> case_GenesisMint)) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) unitval) unitval)) (delay (go xs)))) (\sc -> go xs) (\ref -> go xs)) (delay (force (force fstPair) (force tup)))) (delay (unConstrData i))))))))))))) (delay (force (force (findOwnInput ctx) (\i -> delay (force i (\ds -> \ds -> ds))) (delay ((\thunk -> error) ((\wild -> unitval) (force trace "No Script Input" Unit)))))))) (delay (force (force (getContinuingOutputs ctx) (delay (fail ())) (\o -> \ds -> delay (force (force ds (delay o) (\ipv -> \ipv -> delay (fail ()))))))))) (\ds -> \k -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> force (force (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidFirst) (\x -> force (force (force ifThenElse (equalsByteString k x) True False) (delay (force Just x)) (delay (force Nothing)))) ds) (\ds -> delay True) (delay False))))) (delay (delay (\dFoldable -> \t -> force (force dFoldable) ((\v -> force CConsMonoid (\eta -> \eta -> force p1Monoid v eta eta) (force mempty v)) (force CConsMonoid (\ds -> \ds -> \x -> ds (ds x)) (\x -> x))) (\x -> \y -> addInteger y 1) t 0)))) (\ctx -> force (force (findOwnInput ctx) (\ds -> delay (force ds (\ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> force ctx (\ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> force (force (foldr (delay (\x -> x)))) (\e -> \xs -> force e (\ds -> \ds -> \ds -> \ds -> force (force (force ds (\ww -> \ww -> force ds (\ww -> \ww -> (\j -> force ww (\l -> force ww (\r -> force (force (force ifThenElse (equalsByteString l r) True False) (delay (force j)) (delay False))) (\ipv -> False)) (\a -> force ww (\ipv -> False) (\a -> force (force (force ifThenElse (equalsByteString a a) True False) (delay (force j)) (delay False))))) (delay (force (force ww (\a -> delay (force (force ww (\a -> delay (force a (\l -> force a (\r -> force l (\l -> force r (\r -> equalsByteString l r) (\ipv -> False)) (\a -> force r (\ipv -> False) (\a -> equalsByteString a a))) (\ipv -> \ipv -> \ipv -> False)) (\a -> \b -> \c -> force a (\ipv -> False) (\a -> \b -> \c -> force (force (force ifThenElse (equalsInteger a a) True False) (delay (force (force (force ifThenElse (equalsInteger b b) True False) (delay (equalsInteger c c)) (delay False)))) (delay False)))))) (delay False)))) (delay (force (force ww (\ipv -> delay False) (delay True)))))))))) (delay (force Cons e xs)) (delay xs)))) (force Nil) ds)))))) (delay ((\thunk -> error) ((\wild -> unitval) (force trace "Lf" Unit))))))) (\ds -> force ds (\ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> \ds -> force ds (\default_arg0 -> force Nothing) (\default_arg0 -> force Nothing) (\default_arg0 -> force Nothing) (\txOutRef -> force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidFirst) (\x -> force x (\ds -> \ds -> force (force (force (force (force ifThenElse (equalsByteString (force ds (\ds -> \ds -> ds)) (force txOutRef (\ds -> \ds -> ds))) True False) (delay (force ifThenElse (equalsInteger (force ds (\ds -> \ds -> ds)) (force txOutRef (\ds -> \ds -> ds))) True False)) (delay False))) (delay (force Just x)) (delay (force Nothing))))) ds))))) (delay (force CConsMonoid (\ds -> \b -> force (force ds (\ipv -> delay ds) (delay b))) (force Nothing)))) (\v -> goOuter (force Nil) v)) ((\arg_0 -> arg_0) (force (force fix1) (\goOuter -> \acc -> \ds -> force (force ds (delay acc) (\ipv -> \ipv -> delay (force ipv (\cs -> \m -> goOuter (goInner cs acc m) ipv)))))))) ((\arg_0 -> arg_0) (force (force fix1) (\goInner -> \ds -> \acc -> \ds -> force (force ds (delay acc) (\ipv -> \ipv -> delay (force ipv (\tn -> \a -> force (force (force ifThenElse (equalsInteger a 0) True False) (delay (goInner ds acc ipv)) (delay (goInner ds (force Cons (delay (\case_Tuple3 -> case_Tuple3 ds tn a)) acc) ipv))))))))))) (delay (\w -> \w -> \w -> force w (\ww -> \ww -> force ww (\ww -> \ww -> force w (\ww -> \ww -> force ww (\ww -> \ww -> force (force (force hull_ccompare w ww ww) (delay (force (force ww (delay (force (force ww (delay (force fOrdUpperBound0_c w ww ww)) (delay False)))) (delay (force fOrdUpperBound0_c w ww ww))))) (delay False) (delay (force fOrdUpperBound0_c w ww ww)))))))))) (delay (\arg_0 -> \arg_1 -> delay (\case_Interval -> case_Interval arg_0 arg_1)))) (delay (\arg_0 -> \arg_1 -> delay (\case_LowerBound -> case_LowerBound arg_0 arg_1)))) (delay (\w -> \w -> \w -> force w (\ww -> \ww -> force w (\ww -> \ww -> force (force (force hull_ccompare w ww ww) (delay (force (force ww (delay ww) (delay True)))) (delay False) (delay True))))))) (delay (\arg_0 -> \arg_1 -> delay (\case_UpperBound -> case_UpperBound arg_0 arg_1)))) (delay (\dOrd -> \ds -> \ds -> (\fail -> (\fail -> (\fail -> (\fail -> force (force ds (\default_arg0 -> delay (force (force ds (\default_arg0 -> delay (force (force ds (\default_arg0 -> delay (fail ())) (delay (fail ())) (delay (force (force ds (\default_arg0 -> delay (fail ())) (delay (fail ())) (delay EQ))))))) (delay GT) (delay (force (force ds (\default_arg0 -> delay (fail ())) (delay (fail ())) (delay (force (force ds (\default_arg0 -> delay (fail ())) (delay (fail ())) (delay EQ)))))))))) (delay (force (force ds (\default_arg0 -> delay LT) (delay EQ) (delay LT)))) (delay (force (force ds (\default_arg0 -> delay (force (force ds (\default_arg0 -> delay (fail ())) (delay (fail ())) (delay (force (force ds (\default_arg0 -> delay (fail ())) (delay (fail ())) (delay EQ))))))) (delay GT) (delay (force (force ds (\default_arg0 -> delay (fail ())) (delay (fail ())) (delay (force (force ds (\default_arg0 -> delay (fail ())) (delay (fail ())) (delay EQ)))))))))))) (\ds -> force (force ds (\default_arg0 -> delay (force (force ds (\l -> delay (force (force ds (\r -> delay (force compare dOrd l r)) (delay error) (delay error)))) (delay error) (delay GT)))) (delay (force (force ds (\l -> delay (force (force ds (\r -> delay (force compare dOrd l r)) (delay error) (delay error)))) (delay error) (delay GT)))) (delay LT)))) (\ds -> force (force ds (\default_arg0 -> delay (force (force ds (\l -> delay (force (force ds (\r -> delay (force compare dOrd l r)) (delay error) (delay error)))) (delay error) (delay GT)))) (delay (force (force ds (\l -> delay (force (force ds (\r -> delay (force compare dOrd l r)) (delay error) (delay error)))) (delay error) (delay GT)))) (delay LT)))) (\ds -> force (force ds (\default_arg0 -> delay (force (force ds (\l -> delay (force (force ds (\r -> delay (force compare dOrd l r)) (delay error) (delay error)))) (delay error) (delay GT)))) (delay (force (force ds (\l -> delay (force (force ds (\r -> delay (force compare dOrd l r)) (delay error) (delay error)))) (delay error) (delay GT)))) (delay LT)))) (\ds -> force (force ds (\default_arg0 -> delay (force (force ds (\l -> delay (force (force ds (\r -> delay (force compare dOrd l r)) (delay error) (delay error)))) (delay error) (delay GT)))) (delay (force (force ds (\l -> delay (force (force ds (\r -> delay (force compare dOrd l r)) (delay error) (delay error)))) (delay error) (delay GT)))) (delay LT)))))) (delay (\arg_0 -> delay (\case_Finite -> \case_NegInf -> \case_PosInf -> case_Finite arg_0))) (delay (delay (\case_Finite -> \case_NegInf -> \case_PosInf -> case_PosInf)))) (delay (\v -> force v (\v -> \v -> \v -> \v -> \v -> \v -> \v -> \v -> v)))) (\f -> \l -> \r -> force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidProduct (force fMultiplicativeMonoidBool)) (\ds -> force ds (\ds -> \a -> force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) (force fMonoidProduct (force fMultiplicativeMonoidBool)) (\ds -> force ds (\ds -> \a -> force a (\b -> f 0 b) (\a -> \b -> f a b) (\a -> f a 0))) a)) (force (force (fFunctorNil_cfmap (delay (\x -> x)))) (\ds -> force ds (\c -> \a -> force (force Tuple2) c (force a (\b -> force (force (fFunctorNil_cfmap (delay (\x -> x)))) (\ds -> force ds (\c -> \a -> force (force Tuple2) c (force (force That) a))) b) (\a -> \b -> force (force (force union)) equalsByteString a b) (\a -> force (force (fFunctorNil_cfmap (delay (\x -> x)))) (\ds -> force ds (\c -> \a -> force (force Tuple2) c (force (force This) a))) a)))) (force (force (force union)) equalsByteString l r)))) (delay (delay (delay (\dEq -> \ds -> \ds -> force (force (foldr (delay (\x -> x)))) (force Cons) (force (force (fFunctorNil_cfmap (delay (\x -> x)))) (\ds -> force ds (\c -> \a -> force (force Tuple2) c (force (force That) a))) (force (force (foldr (delay (\x -> x)))) (\e -> \xs -> force e (\c -> \ds -> force (force (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) ((\v -> force CConsMonoid (\eta -> \eta -> force v (\v -> \v -> v) eta eta) (force v (\v -> \v -> v))) (delay (\case_CConsAdditiveMonoid -> case_CConsAdditiveMonoid (\l -> \r -> force (force l (delay True) (delay r))) False))) (\ds -> force ds (\c -> \ds -> dEq c c)) ds) (delay xs) (delay (force Cons e xs))))) (force Nil) ds)) (force (force (fFunctorNil_cfmap (delay (\x -> x)))) (\ds -> force ds (\c -> \i -> (\go -> force (force Tuple2) c (go ds)) ((\arg_0 -> arg_0) (force (force fix1) (\go -> \ds -> force (force ds (delay (force (force This) i)) (\ds -> \xs -> delay (force ds (\c -> \i -> force (force (dEq c c) (delay (delay (\case_That -> \case_These -> \case_This -> case_These i i))) (delay (go xs)))))))))))) ds)))))) ((\arg_0 -> arg_0) (force (force fix1) (\foldr -> \arg -> delay (delay (\f -> \acc -> \l -> force (force l (delay acc) (\x -> \xs -> delay (f x (force (force (foldr (delay (\x -> x)))) f acc xs)))))))))) (delay (delay (\arg_0 -> delay (\case_That -> \case_These -> \case_This -> case_That arg_0)))) (delay (delay (\arg_0 -> delay (\case_That -> \case_These -> \case_This -> case_This arg_0))))) ((\arg_0 -> arg_0) (force (force fix1) (\fFunctorNil_cfmap -> \arg -> delay (delay (\f -> \l -> force (force l (delay (force Nil)) (\x -> \xs -> delay (force Cons (f x) (force (force (fFunctorNil_cfmap (delay (\x -> x)))) f xs)))))))))) ((\arg_0 -> arg_0) (force (force fix1) (\fFoldableNil_cfoldMap -> \arg -> delay (delay (\dMonoid -> \ds -> \ds -> force (force ds (delay (force mempty dMonoid)) (\x -> \xs -> delay (force p1Monoid dMonoid (ds x) (force (force (fFoldableNil_cfoldMap (delay (\x -> x)))) dMonoid ds xs)))))))))) (delay (\v -> force v (\v -> \v -> v)))) (delay (\v -> force v (\v -> \v -> v)))) (delay (delay (\case_CConsMultiplicativeMonoid -> case_CConsMultiplicativeMonoid (\l -> \r -> force (force l (delay r) (delay False))) True)))) (delay (\v -> force CConsMonoid (\eta -> \eta -> force v (\v -> \v -> v) eta eta) (force v (\v -> \v -> v))))) (delay (\arg_0 -> \arg_1 -> delay (\case_CConsMonoid -> case_CConsMonoid arg_0 arg_1)))) (\v -> \ds -> force ds (\c -> \t -> valueOf v c t))) (\ds -> \cur -> \tn -> (\go -> (\go -> go ds) ((\arg_0 -> arg_0) (force (force fix1) (\go -> \ds -> force ds 0 (\ds -> \xs -> force ds (\c -> \i -> force (force (force ifThenElse (equalsByteString c cur) True False) (delay (go i)) (delay (go xs))))))))) ((\arg_0 -> arg_0) (force (force fix1) (\go -> \ds -> force ds 0 (\ds -> \xs -> force ds (\c -> \i -> force (force (force ifThenElse (equalsByteString c tn) True False) (delay i) (delay (go xs)))))))))) (\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> delay (\case_Address -> case_Address arg_0 arg_1)) (fUnsafeFromDataCredential_cunsafeFromBuiltinData (force headList (force t))) ((\d -> (\tup -> (\index -> force ifThenElse (equalsInteger (force index) 0) (\ds -> force Just ((\d -> (\tup -> (\t -> (\t -> (\index -> force ifThenElse (equalsInteger (force index) 1) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> delay (\case_StakingHash -> \case_StakingPtr -> case_StakingPtr arg_0 arg_1 arg_2)) (unIData (force headList (force t))) (unIData (force headList (force t))) (unIData (force headList (force tailList (force t))))) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> (\arg_0 -> delay (\case_StakingHash -> \case_StakingPtr -> case_StakingHash arg_0)) (fUnsafeFromDataCredential_cunsafeFromBuiltinData (force headList (force (force sndPair) (force tup))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 1) (\ds -> force Nothing) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (unConstrData d))) (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d)))) (\d -> (\tup -> (\index -> force ifThenElse (equalsInteger (force index) 1) (\ds -> (\arg_0 -> delay (\case_PubKeyCredential -> \case_ScriptCredential -> case_ScriptCredential arg_0)) (unBData (force headList (force (force sndPair) (force tup))))) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> (\arg_0 -> delay (\case_PubKeyCredential -> \case_ScriptCredential -> case_PubKeyCredential arg_0)) (unBData (force headList (force (force sndPair) (force tup))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) (delay (force (force fstPair) (force tup)))) (delay (unConstrData d)))) (\d -> (\tup -> (\t -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> delay (\case_DistroDatum -> case_DistroDatum arg_0 arg_1 arg_2)) ((\d -> (\tup -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> force (force Tuple2) (unBData (force headList (force t))) (unBData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force t))) ((\d -> (\tup -> (\t -> (\t -> (\t -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> \arg_3 -> \arg_4 -> delay (\case_PhaseOneInfo -> case_PhaseOneInfo arg_0 arg_1 arg_2 arg_3 arg_4)) (unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force t))) (unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force t))) (unIData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force t))) ((\d -> (\tup -> (\t -> (\t -> (\t -> (\t -> force ifThenElse (equalsInteger (force (force fstPair) (force tup)) 0) (\ds -> (\arg_0 -> \arg_1 -> \arg_2 -> \arg_3 -> \arg_4 -> delay (\case_PhaseTwoInfo -> case_PhaseTwoInfo arg_0 arg_1 arg_2 arg_3 arg_4)) (unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force t))) (unIData (force headList (force t))) (fUnsafeFromDataBool_cunsafeFromBuiltinData (force headList (force t))) (unIData (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d))) (force headList (force tailList (force t))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) (delay (force tailList (force t)))) (delay (force (force sndPair) (force tup)))) (delay (unConstrData d)))) (\d -> (\index -> force ifThenElse (equalsInteger (force index) 1) (\ds -> True) (\ds -> force ifThenElse (equalsInteger (force index) 0) (\ds -> False) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace reconstructCaseError Unit))) unitval) unitval) (delay (force (force fstPair) (unConstrData d))))) "PT1") (delay (delay (\case_CConsOrd -> case_CConsOrd equalsInteger (\x -> \y -> force (force (force ifThenElse (equalsInteger x y) True False) (delay EQ) (delay (force (force (force ifThenElse (lessThanEqualsInteger x y) True False) (delay LT) (delay GT)))))) (\x -> \y -> force ifThenElse (lessThanInteger x y) True False) (\x -> \y -> force ifThenElse (lessThanEqualsInteger x y) True False) (\x -> \y -> force ifThenElse (lessThanEqualsInteger x y) False True) (\x -> \y -> force ifThenElse (lessThanInteger x y) False True) (\x -> \y -> force (force (force ifThenElse (lessThanEqualsInteger x y) True False) (delay y) (delay x))) (\x -> \y -> force (force (force ifThenElse (lessThanEqualsInteger x y) True False) (delay x) (delay y))))))) (delay (\case_EQ -> \case_GT -> \case_LT -> case_EQ)) (delay (\case_EQ -> \case_GT -> \case_LT -> case_GT)) (delay (\case_EQ -> \case_GT -> \case_LT -> case_LT))) (\a -> \b -> (\j -> (\j -> force (force (force ifThenElse (equalsInteger (force a (\ds -> \ds -> \ds -> \ds -> \ds -> ds)) (force b (\ds -> \ds -> \ds -> \ds -> \ds -> ds))) True False) (delay (force a (\ds -> \ds -> \ds -> \ds -> \ds -> force (force ds (delay (force b (\ds -> \ds -> \ds -> \ds -> \ds -> force (force ds (delay (force j)) (delay False))))) (delay (force b (\ds -> \ds -> \ds -> \ds -> \ds -> force (force ds (delay False) (delay (force j)))))))))) (delay False))) (delay (force (force (force ifThenElse (equalsInteger (force a (\ds -> \ds -> \ds -> \ds -> \ds -> ds)) (force b (\ds -> \ds -> \ds -> \ds -> \ds -> ds))) True False) (delay (force a (\ds -> \ds -> \ds -> \ds -> \ds -> force (force ds (delay (force b (\ds -> \ds -> \ds -> \ds -> \ds -> force (force ds (delay (force j)) (delay False))))) (delay (force b (\ds -> \ds -> \ds -> \ds -> \ds -> force (force ds (delay False) (delay (force j)))))))))) (delay False))))) (delay (force ifThenElse (equalsInteger (force a (\ds -> \ds -> \ds -> \ds -> \ds -> ds)) (force b (\ds -> \ds -> \ds -> \ds -> \ds -> ds))) True False)))) (\w -> \w -> force w (\ww -> \ww -> force w (\ww -> \ww -> force (force (force ifThenElse (equalsByteString ww ww) True False) (delay (equalsByteString ww ww)) (delay False)))))) (\x -> \y -> force ifThenElse (equalsByteString x y) True False)) (\utxos -> \number -> (\loopInputs -> loopInputs utxos 0) ((\arg_0 -> arg_0) (force (force fix1) (\loopInputs -> \ds -> \counter -> force (force ds (delay (equalsInteger counter number)) (\x -> \xs -> delay (force x (\ds -> \ds -> \ds -> \ds -> force (force ds (delay (loopInputs xs counter)) (\default_arg0 -> delay (loopInputs xs (addInteger counter 1))) (\default_arg0 -> delay (loopInputs xs (addInteger counter 1))))))))))))) (\utxos -> \number -> (\loopInputs -> loopInputs utxos 0) ((\arg_0 -> arg_0) (force (force fix1) (\loopInputs -> \ds -> \counter -> force (force ds (delay (equalsInteger counter number)) (\x -> \xs -> delay (force x (\ds -> \ds -> force ds (\ds -> \ds -> \ds -> \ds -> force (force ds (delay (loopInputs xs counter)) (\default_arg0 -> delay (loopInputs xs (addInteger counter 1))) (\default_arg0 -> delay (loopInputs xs (addInteger counter 1)))))))))))))) (\x -> \y -> force ifThenElse (equalsInteger x y) True False)) (\address -> force address (\ds -> \ds -> force ds (\k -> k) (\ipv -> (\thunk -> error) ((\wild -> unitval) (force trace "No PubKeyHash" Unit)))))) (\ds -> (\thunk -> error) ((\wild -> unitval) (force trace "No Script Output" Unit)))) ()) (delay (delay (\case_Nil -> \case_Cons -> case_Nil))) (delay (\arg_0 -> \arg_1 -> delay (\case_Nil -> \case_Cons -> case_Cons arg_0 arg_1)))) (delay (delay (\arg_0 -> \arg_1 -> delay (\case_Tuple2 -> case_Tuple2 arg_0 arg_1))))) (delay (\arg_0 -> delay (\case_Just -> \case_Nothing -> case_Just arg_0))) (delay (delay (\case_Just -> \case_Nothing -> case_Nothing)))) (delay (\case_Unit -> case_Unit))) (delay (force trace "One Or More Dev Has Not Claim Their Token" False))) (delay (force trace "Incorrect Tx In/Out" False))) (delay (force trace "One Or More Dev Has Not Claim Their Token" False))) (delay (force trace "Incorrect Tx In/Out" False))) (delay (force trace "firstDevDidPhaseOne Mismatched" False))) (delay (force trace "secondDevDidPhaseOne Mismatched" False))) (delay (force trace "Incorrect Tx In/Out" False))) (delay (force trace "firstDevDidPhaseOne Mismatched" False))) (delay (force trace "secondDevDidPhaseOne Mismatched" False))) (delay (force trace "Incorrect Tx In/Out" False))) (delay (force trace "Wrong Amount Minted By First Developer" False))) (delay (force trace "firstDevDidPhaseOne Mismatched" False))) (delay (force trace "secondDevDidPhaseOne Mismatched" False))) (delay (force trace "firstDevDidPhaseTwo Mismatched" False))) (delay (force trace "secondDevDidPhaseTwo Mismatched" False))) (delay (force trace "Incorrect Tx In/Out" False))) (delay (force trace "Wrong Amount Minted By Second Developer" False))) (delay (force trace "firstDevDidPhaseOne Mismatched" False))) (delay (force trace "secondDevDidPhaseOne Mismatched" False))) (delay (force trace "firstDevDidPhaseTwo Mismatched" False))) (delay (force trace "secondDevDidPhaseTwo Mismatched" False))) (delay (force trace "Incorrect Tx In/Out" False))) (delay (\case_True -> \case_False -> case_True)) (delay (\case_True -> \case_False -> case_False))) (delay (delay (\f -> (\s -> s s) (\s -> \x -> f (s s) x)))) #bdc24850053ddf1e0c53bf20a518dcc4dcc5200ac4adb0056a1ded5c))